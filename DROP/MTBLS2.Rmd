MTBLS2 Processing and Analysis with xcms, CAMERA and export to MetaboLights
========================================================

Kenneth Haug and Reza M. Salek and Pablo Conesa and
  Janna Hastings and Paula de Matos and Mark Rijnbeek and
  Tejasvi Mahendraker and Mark Williams and Steffen Neumann 
  and Christoph Böttcher and
  Philippe Rocca-Serra and Eamonn Maguire and Alejandra
  González-Beltrán and Susanna-Assunta Sansone and Julian
  L. Griffin and Christoph Steinbeck


```{r LibraryPreload, message=FALSE}
library(Risa)
library(xcms)
library(CAMERA)
library(pcaMethods)
library(Heatplus)
library(sp)

````

## Introduction 

Since 2006, the Bioconductor package [xcms](http://bioconductor.org/packages/release/bioc/html/xcms.html)
[Smith 2006](http://www.ncbi.nlm.nih.gov/pubmed/16448051) provides a rich set of
algorithms for mass spectrometry data processing. Typically, xcms will
create an xcmsSet object from several raw data files in an assay,
which are obtained from the samples in the study.  
Allowed raw data formats are netCDF, mzData, mzXML and mzML.

In this vignette, we demonstrate the processing of the MTBLS2 dataset, 
which was described in [Neumann 2012](http://www.springerlink.com/content/l148485q75010101).

## A few global settings

A few things might be worth to define at the beginning of an analysis

```{r settings} 
## How many CPU cores has your machine (or cluster) ?
nSlaves=2

# prefilter <- c(3,200)  ## standard
# scanrange=c(0,2900)    ## standard

prefilter=c(5,500)      ## quick-run for debuggung

```

## Raw data conversion

This can be done with the vendor tools, or the open source proteowizard converter. The preferred format should be mzML or mzData/mzXML. An overview of formats (and problems) is available at the [xcms online](https://xcmsonline.scripps.edu/docs/fileformats.html) help pages.

## R and ISAtab

An ISAtab archive will contain the metadata description in 
several tab-separated files. (One of) the assay files contains the column ``Raw Spectral Data File``
with the paths to the mass spectral raw data files in one of the above formats. 

```{r rISA, cache=TRUE}
ISAmtbls2 <- readISAtab()
a.filename <- ISAmtbls2["assay.filenames"][[1]]

````

## ISAtab, Risa and xcms

With the combination of [Risa](http://bioconductor.org/packages/release/bioc/html/Risa.html) and xcms, we can convert the MS raw data in an ISAtab archive into an xcmsSet:

```{r PeakPicking, cache=TRUE, warning=FALSE}
mtbls2Set <- processAssayXcmsSet(ISAmtbls2, a.filename,
                                 method="centWave", prefilter=prefilter, 
                                 snthr=25, verbose.columns=T,
                                 ppm=25, #scanrange=scanrange, 
                                 peakwidth=c(5,12),
                                 nSlaves=nSlaves)
````


## How good is `fillPeaks()` ?

`fillPeaks()` will add intensities for peaks not observed in a certain sample, but in some/most of the other samples of a smple class. The question is:
How good does `fillPeaks()` estimate the intenisty for my data ?
One way to estimate the quality is to take an xcmsSet grouped without NA values (i.e. one class and minfrac=1), remove the peaks of one sample, and fill them back in.
This way you can create a scatterplot of found peaks vs. filled peaks, and also check for which intensities they occur:

```{r checkFillPeaksprepare}

if (FALSE) {
 xsgOrig <- mtbls2Set
 phenoData(xsgOrig) <- rep("dummy", length(sampnames(xsgOrig)))

 xsgOrig <- group(xsgOrig, minfrac=1) ## The xcmsSet with "true" intensities and without NAs

 ## remove extra peaks within groups
 xsg <- xsgOrig
 peaks <- cbind(peaks(xsg),(1:nrow(peaks(xsg))))
 meds <- as.vector(groupval(xsg,"medret"))
 meds <- meds[which(!is.na(meds))]
 peaks <-peaks[meds,]
 colnames(peaks) <- c(colnames(peaks(xsg)),"index")
 
 ## cleanup groupidx list
 for (a in 1: length(groupidx(xsg))) {
     gxs=NULL
     for (b in 1:length(groupidx(xsg)[[a]])){
         if (any(meds == groupidx(xsg)[[a]][b]))
             gxs<-c(gxs,groupidx(xsg)[[a]][b])
     }
     groupidx(xsg)[[a]] <- gxs
 }
 
 ## change index in groupidx
 for (a in 1: length(groupidx(xsg))) {
     gxs=NULL
     for (b in 1:length(groupidx(xsg)[[a]])){
         groupidx(xsg)[[a]][b] <- which(peaks[,"index"]==groupidx(xsg)[[a]][b])
     }
 }
 
 ## Write "cleaned" peaklist
 peaks(xsg) <- peaks[,(1:(ncol(peaks)-1))]
 
 ## remove peaks from last sample
 lasts <- max(peaks(xsg)[,"sample"])
 lsmin <- min(which(peaks(xsg)[,"sample"]==lasts))
 
 ## remove peaksIDs from groupidx
 for (a in 1: length(groupidx(xsg))){
     groupidx(xsg)[[a]] <- groupidx(xsg)[[a]][which(groupidx(xsg)[[a]]<lsmin)]
 }
 
 ## remove peaks from peaklist
 peaks(xsg) <- peaks(xsg)[1:(lsmin-1),]
}
```

Now we have an xcmsSet, where the last sample has been deprived of all its peaks.
Let's fill them back in:

```{r checkFillPeak, fig.show="hold", message=FALSE, warning=FALSE}
 ##
 ## Preparations finished, now fillPeaks()
 ##
if (FALSE) {
  xsgf <- fillPeaks(xsg)
  
 ## compare peaks in both xcmsSets groupwise and samplewise
 gxorig <- groupidx(xsgOrig) ## das fillpeaks-ergebnis des backups
 gxfill <- groupidx(xsgf) ## das fillpeaks-ergebnis des XS ohne sample lasts
 
 ## plot original and filled peaks
 mxo<-NA
 mxf<-NA
 ino<-NA
 inf<-NA
 for (a in 1: length(gxorig))
 {    
     opeak <- gxorig[[a]][which(peaks(xsgOrig)[gxorig[[a]],"sample"]==length(sampnames(xsgOrig)))]
     fpeak <- gxfill[[a]][which(peaks(xsgf)[gxfill[[a]],"sample"]==length(sampnames(xsgOrig)))]
     mxo[a] <- peaks(xsgOrig)[opeak,"mz"]
     mxf[a] <- peaks(xsgf)[fpeak,"mz"]
     ino[a] <- peaks(xsgOrig)[opeak,"into"]
     inf[a] <- peaks(xsgf)[fpeak,"into"]
 }
 
 
 plot(log(ino),log(inf), pch=".")
  
 plot(ino,inf/ino, pch=".", log="x")
 }
```
